// Licensed to Inria Grand-Est / Loria under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  Inria Grand-Est / Loria licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

/**
 * Default encryption to use. AES-GCM uses an IV and outputs a ciphertext which also contains an authenticated tag.
 */
const encryptionAlgo = 'AES-GCM'
const keySize = 128
/**
 * Default initialization vector length (in bytes) to use.
 */
const ivLength = 12
/**
 * Default authentication tag length (in bits) to use.
 */
const tagLength = 128

export const defaultSymmetricEncryptionParams = {
  /**
   * Default encryption Algorithm to use.
   */
  name: encryptionAlgo,
  /**
   * Default key size to use.
   * 128, 192 or 256 for AES.
   */
  length: keySize,
}

export const defaultImportEncryptionParams = {
  /**
   * Default encryption Algorithm to use.
   */
  name: encryptionAlgo,
}

/**
 * getDefaultEncryptParams returns the object containing the parameters needed by the encrypt function.
 *
 * @params generateNewNonce Should be true if used for encrypting, false if used for decrypting.
 */
export function getDefaultEncryptParams(generateNewNonce: boolean): { name: string; iv: Uint8Array; length: number; tagLength: number } {
  if (generateNewNonce) {
    return { name: encryptionAlgo, iv: generateNonce(), length: keySize, tagLength }
  } else {
    return { name: encryptionAlgo, iv: new Uint8Array(), length: keySize, tagLength }
  }
}

/**
 * joinNonceCiphertext concatenates the nonce and the ciphertext.
 *
 * @params nonce The nonce generated by calling {@link getDefaultEncryptParams}.
 */
export function joinNonceCiphertext(nonce: Uint8Array, ciphertext: Uint8Array): Promise<Uint8Array> {
  return new Promise((resolve) => {
    const result = new Uint8Array(nonce.length + ciphertext.length)
    result.set(nonce)
    result.set(ciphertext, nonce.length)
    resolve(result)
  })
}

/**
 * joinNonceCiphertext concatenates the nonce and the ciphertext.
 *
 * @params data The concatenation of the nonce and the ciphertext.
 * @returns An array containing the nonce and the ciphertext
 */
export function splitNonceCiphertext(data: Uint8Array): Promise<[Uint8Array, Uint8Array]> {
  return new Promise((resolve) => {
    let result: [Uint8Array, Uint8Array]
    const nonce = data.slice(0, ivLength)
    const ciphertext = data.slice(ivLength, data.length)
    result = [nonce, ciphertext]
    resolve(result)
  })
}

function generateNonce(): Uint8Array {
  return global.crypto.getRandomValues(new Uint8Array(ivLength)) as Uint8Array
}
