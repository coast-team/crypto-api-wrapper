// Licensed to Inria Grand-Est / Loria under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  Inria Grand-Est / Loria licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import { g, KDFDeriveKeyParams, KDFKeyParams, p } from './helper/keyAgreementCryptoHelper'

import BN = require('bn.js')

/**
 * Prime number to use with the different modular operations.
 */
const red = BN.mont(p)
// const BN = require('bn.js')

/**
 * deriveKey derives a symmetric key given a shared secret.
 * @param sharedSecret the shared secret computed with the key agreement protocol.
 */
export async function deriveKey(sharedSecret: Uint8Array): Promise<CryptoKey> {
  const HKDFKey = await global.crypto.subtle.importKey(
    KDFKeyParams.format,
    sharedSecret,
    KDFKeyParams.algorithm,
    KDFKeyParams.extractable,
    KDFKeyParams.keyUsages
  )
  return global.crypto.subtle.deriveKey(
    KDFDeriveKeyParams.info,
    HKDFKey,
    KDFDeriveKeyParams.symmKeyParams,
    KDFDeriveKeyParams.extractable,
    KDFDeriveKeyParams.keyUsages
  )
}

/**
 * computeZi computes the first value to broadcast to all users.
 * @param ri the random number generated by the user.
 */
export function computeZi(ri: Uint8Array) {
  return g
    .toRed(red)
    .redPow(new BN(ri as Buffer) as any)
    .fromRed()
}

/**
 * computeXi computes the second value to broadcast to  all users once the zi from the left and right neighbor is received.
 * @param ri the random number generated by the user.
 * @param ziRight the computed zi by the 'left' neighbor (in a cycle)
 * @param ziLeft the computed zi by the 'right' neighbor (in a cycle)
 */
export function computeXi(ri: Uint8Array, ziRight: BN, ziLeft: BN) {
  const modInvM = ziLeft.toRed(red).redInvm()
  return modInvM
    .redMul(ziRight.toRed(red))
    .redPow(new BN(ri as Buffer) as any)
    .fromRed()
}

/**
 * ComputeSki computes the shared secret.
 * @param ri the random number generated by the user.
 * @param xi the xi computed by the user.
 * @param ziLeft the computed zi by the 'right' neighbor (in a cycle)
 * @param xiList the list of all the xi computed by all the users.
 */
export function computeSKi(ri: Uint8Array, xi: BN, ziLeft: BN, xiList: BN[]) {
  const res = ziLeft.toRed(red).redPow(new BN(ri as Buffer).mul(new BN(xiList.length)) as any)
  const iInit = indexOf(xiList, xi)
  const exponent = new BN(xiList.length - 1)
  let xin
  let ind: number
  for (let i = 0; exponent.gtn(0); i++) {
    ind = (iInit + i) % xiList.length
    xin = xiList[ind].toRed(red).redPow(exponent as any)
    res.redIMul(xin)
    exponent.isubn(1)
  }
  return res.fromRed().toArrayLike(Uint8Array as any) as Uint8Array
}

function indexOf(xiList: BN[], xi: BN) {
  let indexOfXi = -1
  xiList.forEach((element, index) => {
    if (element.eq(xi)) {
      indexOfXi = index
    }
  })
  return indexOfXi
}
